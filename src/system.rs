use super::world::{ComponentStorage, World};
use super::event::{EventReceiver, EventSender};

pub trait SystemStorage {
	fn new() -> Self;
    fn halt(&self) -> bool;
    fn update<C, Q, E>(&mut self, world: &mut World<C>, queue: &mut Q, emitter: &mut E, dt: f32)
    	where C: ComponentStorage, Q: EventReceiver<E>, E: EventSender;
}

/// Trait that must be implemented by all systems in the `Simulation`. The generic parameter `E` is
/// the `Events` type generated by the `simulation!` macro.
pub trait System {
    /// `System`s should be initializable with an empty constructor.
    fn new() -> Self;

    /// This method is called each frame, giving the `System` mutable access to the `World` and
    /// `Events`. `dt` is the time in milliseconds since the last update.
    fn update<C, Q, E>(&mut self, world: &mut World<C>, queue: &Q, emitter: &mut E, dt: f32) where C: ComponentStorage, Q: EventReceiver<E>, E: EventSender;
}
